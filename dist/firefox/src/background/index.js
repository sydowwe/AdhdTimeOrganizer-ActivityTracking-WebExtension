var Se=Object.defineProperty;var Ee=(E,v,C)=>v in E?Se(E,v,{enumerable:!0,configurable:!0,writable:!0,value:C}):E[v]=C;var f=(E,v,C)=>Ee(E,typeof v!="symbol"?v+"":v,C);(function(){"use strict";var E=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function v(i){return i&&i.__esModule&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i}var C={exports:{}};(function(i,e){(function(t,s){s(i)})(typeof globalThis<"u"?globalThis:typeof self<"u"?self:E,function(t){if(!(globalThis.chrome&&globalThis.chrome.runtime&&globalThis.chrome.runtime.id))throw new Error("This script should only be loaded in a browser extension.");if(globalThis.browser&&globalThis.browser.runtime&&globalThis.browser.runtime.id)t.exports=globalThis.browser;else{const s="The message port closed before a response was received.",n=g=>{const u={alarms:{clear:{minArgs:0,maxArgs:1},clearAll:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getAll:{minArgs:0,maxArgs:0}},bookmarks:{create:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},getChildren:{minArgs:1,maxArgs:1},getRecent:{minArgs:1,maxArgs:1},getSubTree:{minArgs:1,maxArgs:1},getTree:{minArgs:0,maxArgs:0},move:{minArgs:2,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeTree:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}},browserAction:{disable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},enable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},getBadgeBackgroundColor:{minArgs:1,maxArgs:1},getBadgeText:{minArgs:1,maxArgs:1},getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},openPopup:{minArgs:0,maxArgs:0},setBadgeBackgroundColor:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setBadgeText:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},browsingData:{remove:{minArgs:2,maxArgs:2},removeCache:{minArgs:1,maxArgs:1},removeCookies:{minArgs:1,maxArgs:1},removeDownloads:{minArgs:1,maxArgs:1},removeFormData:{minArgs:1,maxArgs:1},removeHistory:{minArgs:1,maxArgs:1},removeLocalStorage:{minArgs:1,maxArgs:1},removePasswords:{minArgs:1,maxArgs:1},removePluginData:{minArgs:1,maxArgs:1},settings:{minArgs:0,maxArgs:0}},commands:{getAll:{minArgs:0,maxArgs:0}},contextMenus:{remove:{minArgs:1,maxArgs:1},removeAll:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},cookies:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:1,maxArgs:1},getAllCookieStores:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},devtools:{inspectedWindow:{eval:{minArgs:1,maxArgs:2,singleCallbackArg:!1}},panels:{create:{minArgs:3,maxArgs:3,singleCallbackArg:!0},elements:{createSidebarPane:{minArgs:1,maxArgs:1}}}},downloads:{cancel:{minArgs:1,maxArgs:1},download:{minArgs:1,maxArgs:1},erase:{minArgs:1,maxArgs:1},getFileIcon:{minArgs:1,maxArgs:2},open:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},pause:{minArgs:1,maxArgs:1},removeFile:{minArgs:1,maxArgs:1},resume:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},extension:{isAllowedFileSchemeAccess:{minArgs:0,maxArgs:0},isAllowedIncognitoAccess:{minArgs:0,maxArgs:0}},history:{addUrl:{minArgs:1,maxArgs:1},deleteAll:{minArgs:0,maxArgs:0},deleteRange:{minArgs:1,maxArgs:1},deleteUrl:{minArgs:1,maxArgs:1},getVisits:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1}},i18n:{detectLanguage:{minArgs:1,maxArgs:1},getAcceptLanguages:{minArgs:0,maxArgs:0}},identity:{launchWebAuthFlow:{minArgs:1,maxArgs:1}},idle:{queryState:{minArgs:1,maxArgs:1}},management:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},getSelf:{minArgs:0,maxArgs:0},setEnabled:{minArgs:2,maxArgs:2},uninstallSelf:{minArgs:0,maxArgs:1}},notifications:{clear:{minArgs:1,maxArgs:1},create:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:0},getPermissionLevel:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},pageAction:{getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},hide:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},permissions:{contains:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},request:{minArgs:1,maxArgs:1}},runtime:{getBackgroundPage:{minArgs:0,maxArgs:0},getPlatformInfo:{minArgs:0,maxArgs:0},openOptionsPage:{minArgs:0,maxArgs:0},requestUpdateCheck:{minArgs:0,maxArgs:0},sendMessage:{minArgs:1,maxArgs:3},sendNativeMessage:{minArgs:2,maxArgs:2},setUninstallURL:{minArgs:1,maxArgs:1}},sessions:{getDevices:{minArgs:0,maxArgs:1},getRecentlyClosed:{minArgs:0,maxArgs:1},restore:{minArgs:0,maxArgs:1}},storage:{local:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},managed:{get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1}},sync:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}}},tabs:{captureVisibleTab:{minArgs:0,maxArgs:2},create:{minArgs:1,maxArgs:1},detectLanguage:{minArgs:0,maxArgs:1},discard:{minArgs:0,maxArgs:1},duplicate:{minArgs:1,maxArgs:1},executeScript:{minArgs:1,maxArgs:2},get:{minArgs:1,maxArgs:1},getCurrent:{minArgs:0,maxArgs:0},getZoom:{minArgs:0,maxArgs:1},getZoomSettings:{minArgs:0,maxArgs:1},goBack:{minArgs:0,maxArgs:1},goForward:{minArgs:0,maxArgs:1},highlight:{minArgs:1,maxArgs:1},insertCSS:{minArgs:1,maxArgs:2},move:{minArgs:2,maxArgs:2},query:{minArgs:1,maxArgs:1},reload:{minArgs:0,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeCSS:{minArgs:1,maxArgs:2},sendMessage:{minArgs:2,maxArgs:3},setZoom:{minArgs:1,maxArgs:2},setZoomSettings:{minArgs:1,maxArgs:2},update:{minArgs:1,maxArgs:2}},topSites:{get:{minArgs:0,maxArgs:0}},webNavigation:{getAllFrames:{minArgs:1,maxArgs:1},getFrame:{minArgs:1,maxArgs:1}},webRequest:{handlerBehaviorChanged:{minArgs:0,maxArgs:0}},windows:{create:{minArgs:0,maxArgs:1},get:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:1},getCurrent:{minArgs:0,maxArgs:1},getLastFocused:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}}};if(Object.keys(u).length===0)throw new Error("api-metadata.json has not been included in browser-polyfill");class S extends WeakMap{constructor(o,d=void 0){super(d),this.createItem=o}get(o){return this.has(o)||this.set(o,this.createItem(o)),super.get(o)}}const P=a=>a&&typeof a=="object"&&typeof a.then=="function",H=(a,o)=>(...d)=>{g.runtime.lastError?a.reject(new Error(g.runtime.lastError.message)):o.singleCallbackArg||d.length<=1&&o.singleCallbackArg!==!1?a.resolve(d[0]):a.resolve(d)},M=a=>a==1?"argument":"arguments",xe=(a,o)=>function(m,...A){if(A.length<o.minArgs)throw new Error(`Expected at least ${o.minArgs} ${M(o.minArgs)} for ${a}(), got ${A.length}`);if(A.length>o.maxArgs)throw new Error(`Expected at most ${o.maxArgs} ${M(o.maxArgs)} for ${a}(), got ${A.length}`);return new Promise((T,b)=>{if(o.fallbackToNoCallback)try{m[a](...A,H({resolve:T,reject:b},o))}catch(c){console.warn(`${a} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `,c),m[a](...A),o.fallbackToNoCallback=!1,o.noCallback=!0,T()}else o.noCallback?(m[a](...A),T()):m[a](...A,H({resolve:T,reject:b},o))})},ae=(a,o,d)=>new Proxy(o,{apply(m,A,T){return d.call(A,a,...T)}});let I=Function.call.bind(Object.prototype.hasOwnProperty);const U=(a,o={},d={})=>{let m=Object.create(null),A={has(b,c){return c in a||c in m},get(b,c,k){if(c in m)return m[c];if(!(c in a))return;let h=a[c];if(typeof h=="function")if(typeof o[c]=="function")h=ae(a,a[c],o[c]);else if(I(d,c)){let B=xe(c,d[c]);h=ae(a,a[c],B)}else h=h.bind(a);else if(typeof h=="object"&&h!==null&&(I(o,c)||I(d,c)))h=U(h,o[c],d[c]);else if(I(d,"*"))h=U(h,o[c],d["*"]);else return Object.defineProperty(m,c,{configurable:!0,enumerable:!0,get(){return a[c]},set(B){a[c]=B}}),h;return m[c]=h,h},set(b,c,k,h){return c in m?m[c]=k:a[c]=k,!0},defineProperty(b,c,k){return Reflect.defineProperty(m,c,k)},deleteProperty(b,c){return Reflect.deleteProperty(m,c)}},T=Object.create(a);return new Proxy(T,A)},W=a=>({addListener(o,d,...m){o.addListener(a.get(d),...m)},hasListener(o,d){return o.hasListener(a.get(d))},removeListener(o,d){o.removeListener(a.get(d))}}),ye=new S(a=>typeof a!="function"?a:function(d){const m=U(d,{},{getContent:{minArgs:0,maxArgs:0}});a(m)}),ne=new S(a=>typeof a!="function"?a:function(d,m,A){let T=!1,b,c=new Promise(_=>{b=function(p){T=!0,_(p)}}),k;try{k=a(d,m,b)}catch(_){k=Promise.reject(_)}const h=k!==!0&&P(k);if(k!==!0&&!h&&!T)return!1;const B=_=>{_.then(p=>{A(p)},p=>{let V;p&&(p instanceof Error||typeof p.message=="string")?V=p.message:V="An unexpected error occurred",A({__mozWebExtensionPolyfillReject__:!0,message:V})}).catch(p=>{console.error("Failed to send onMessage rejected reply",p)})};return B(h?k:c),!0}),pe=({reject:a,resolve:o},d)=>{g.runtime.lastError?g.runtime.lastError.message===s?o():a(new Error(g.runtime.lastError.message)):d&&d.__mozWebExtensionPolyfillReject__?a(new Error(d.message)):o(d)},oe=(a,o,d,...m)=>{if(m.length<o.minArgs)throw new Error(`Expected at least ${o.minArgs} ${M(o.minArgs)} for ${a}(), got ${m.length}`);if(m.length>o.maxArgs)throw new Error(`Expected at most ${o.maxArgs} ${M(o.maxArgs)} for ${a}(), got ${m.length}`);return new Promise((A,T)=>{const b=pe.bind(null,{resolve:A,reject:T});m.push(b),d.sendMessage(...m)})},ve={devtools:{network:{onRequestFinished:W(ye)}},runtime:{onMessage:W(ne),onMessageExternal:W(ne),sendMessage:oe.bind(null,"sendMessage",{minArgs:1,maxArgs:3})},tabs:{sendMessage:oe.bind(null,"sendMessage",{minArgs:2,maxArgs:3})}},G={clear:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}};return u.privacy={network:{"*":G},services:{"*":G},websites:{"*":G}},U(g,ve,u)};t.exports=n(chrome)}})})(C);var ge=C.exports;const l=v(ge),D="https://api.example.com",J="/activity",ce="/auth/login",le="/auth/refresh",ue="/auth/logout",O=5e3,de=3e4,me=180,he=6e4;function r(...i){console.log("[TimeOrganizer]",new Date().toISOString(),...i)}function w(...i){console.error("[TimeOrganizer ERROR]",new Date().toISOString(),...i)}function $(i){try{return new URL(i).hostname}catch{return""}}function F(i,e){return e.some(t=>i===t||i.endsWith("."+t))}function L(i,e){return e.trackFullUrlDomains.some(t=>i===t||i.endsWith("."+t))}function R(){return new Date().toISOString()}function Y(){return new Date().toISOString().split("T")[0]}function j(i){return i?!["chrome://","chrome-extension://","moz-extension://","edge://","about:","file://","data:","javascript:","blob:"].some(t=>i.startsWith(t)):!1}const Z={blocklist:[],trackFullUrlDomains:[]};function K(){return{date:Y(),totalActiveTime:0,totalBackgroundTime:0,domainStats:{}}}async function Ae(){try{return(await l.storage.sync.get("settings")).settings||Z}catch(i){return r("Error getting settings:",i),Z}}async function Q(i){try{await l.storage.sync.set({settings:i}),r("Settings saved:",i)}catch(e){throw r("Error saving settings:",e),e}}async function X(){try{const i=Y(),t=(await l.storage.local.get("dailyStats")).dailyStats;if(!t||t.date!==i){const s=K();return await ee(s),s}return t}catch(i){return r("Error getting daily stats:",i),K()}}async function ee(i){try{await l.storage.local.set({dailyStats:i})}catch(e){r("Error saving daily stats:",e)}}async function te(i,e,t){const s=await X();s.domainStats[i]||(s.domainStats[i]={domain:i,activeTime:0,backgroundTime:0,visits:0});const n=s.domainStats[i];t?(n.backgroundTime+=e,s.totalBackgroundTime+=e):(n.activeTime+=e,s.totalActiveTime+=e),n.visits+=1,await ee(s)}async function se(){try{return(await l.storage.local.get("queuedEvents")).queuedEvents||[]}catch(i){return r("Error getting queued events:",i),[]}}async function q(i){try{const t=[...await se(),...i];await l.storage.local.set({queuedEvents:t}),r("Added events to queue, total:",t.length)}catch(e){r("Error adding queued events:",e)}}async function ie(){try{await l.storage.local.set({queuedEvents:[]}),r("Cleared event queue")}catch(i){r("Error clearing queued events:",i)}}async function fe(){try{return(await l.storage.local.get("trackerState")).trackerState||{isPaused:!1,sessionStartTime:Date.now()}}catch(i){return r("Error getting tracker state:",i),{isPaused:!1,sessionStartTime:Date.now()}}}async function Te(i){try{await l.storage.local.set({trackerState:i})}catch(e){r("Error saving tracker state:",e)}}class be{constructor(){f(this,"activeTab",null);f(this,"backgroundTabs",new Map);f(this,"visibleTabs",new Set);f(this,"audibleTabs",new Set);f(this,"pendingEvents",[]);f(this,"isIdle",!1);f(this,"isPaused",!1);f(this,"sessionStartTime",Date.now());f(this,"settings",{blocklist:[],trackFullUrlDomains:[]});f(this,"pendingStarts",new Map)}async initialize(){r("Initializing ActivityTracker"),this.settings=await Ae();const e=await fe();this.isPaused=e.isPaused,this.sessionStartTime=e.sessionStartTime,this.setupEventListeners(),await this.initializeCurrentState(),r("ActivityTracker initialized",{isPaused:this.isPaused,sessionStartTime:this.sessionStartTime})}setupEventListeners(){l.tabs.onActivated.addListener(async e=>{r("Tab activated:",e),await this.handleTabActivated(e.tabId,e.windowId)}),l.windows.onFocusChanged.addListener(async e=>{r("Window focus changed:",e),await this.handleWindowFocusChanged(e)}),l.tabs.onUpdated.addListener(async(e,t,s)=>{t.url&&(r("Tab URL changed:",e,t.url),await this.handleTabUrlChanged(e,t.url)),t.audible!==void 0&&(r("Tab audible changed:",e,t.audible),await this.handleTabAudibleChanged(e,t.audible))}),l.tabs.onRemoved.addListener(async e=>{r("Tab removed:",e),await this.handleTabRemoved(e)}),l.idle.onStateChanged.addListener(async e=>{r("Idle state changed:",e),await this.handleIdleStateChanged(e)}),l.storage.onChanged.addListener((e,t)=>{t==="sync"&&e.settings&&(this.settings=e.settings.newValue,r("Settings updated:",this.settings))}),l.runtime.onMessage.addListener((e,t)=>{var s;e.type==="VISIBILITY_CHANGED"&&((s=t.tab)!=null&&s.id)&&this.handleVisibilityChanged(t.tab.id,e.payload.isVisible)})}async initializeCurrentState(){var e;try{const s=(await l.windows.getAll({windowTypes:["normal"]})).find(u=>u.focused);if(s&&s.id!==void 0){const u=await l.tabs.query({active:!0,windowId:s.id});u.length>0&&u[0].id!==void 0&&await this.handleTabActivated(u[0].id,s.id)}const n=await l.tabs.query({audible:!0});for(const u of n)u.id!==void 0&&(this.audibleTabs.add(u.id),((e=this.activeTab)==null?void 0:e.tabId)!==u.id&&await this.maybeStartBackgroundTracking(u.id,u.url||""));await l.idle.queryState(me)!=="active"&&(this.isIdle=!0)}catch(t){r("Error initializing current state:",t)}}async handleTabActivated(e,t){if(!this.isPaused)try{if(!(await l.windows.get(t)).focused)return;const n=await l.tabs.get(e);if(!n.url||!j(n.url)){await this.endActiveTracking();return}const g=$(n.url);if(F(g,this.settings.blocklist)){await this.endActiveTracking();return}await this.endBackgroundTracking(e),await this.startActiveTracking(e,n.url,g)}catch(s){r("Error handling tab activated:",s)}}async handleWindowFocusChanged(e){if(!this.isPaused)try{if(e===l.windows.WINDOW_ID_NONE){if(this.activeTab){const s=this.activeTab;await this.endActiveTracking();const n=this.visibleTabs.has(s.tabId),g=this.audibleTabs.has(s.tabId);(n||g)&&await this.maybeStartBackgroundTracking(s.tabId,s.url)}return}const t=await l.tabs.query({active:!0,windowId:e});t.length>0&&t[0].id!==void 0&&await this.handleTabActivated(t[0].id,e)}catch(t){r("Error handling window focus changed:",t)}}async handleTabUrlChanged(e,t){var S;if(this.isPaused)return;const s=$(t),n=F(s,this.settings.blocklist),g=j(t);if(((S=this.activeTab)==null?void 0:S.tabId)===e){!g||n?await this.endActiveTracking():this.activeTab.domain!==s?(await this.endActiveTracking(),await this.startActiveTracking(e,t,s)):this.activeTab.url=t;return}const u=this.backgroundTabs.get(e);u&&(!g||n?await this.endBackgroundTracking(e):u.domain!==s?(await this.endBackgroundTracking(e),await this.maybeStartBackgroundTracking(e,t)):u.url=t)}async handleTabAudibleChanged(e,t){var s;if(t){if(this.audibleTabs.add(e),((s=this.activeTab)==null?void 0:s.tabId)!==e){const n=await l.tabs.get(e);n.url&&await this.maybeStartBackgroundTracking(e,n.url)}}else this.audibleTabs.delete(e),this.visibleTabs.has(e)||await this.endBackgroundTracking(e)}handleVisibilityChanged(e,t){r("Visibility changed for tab",e,":",t),t?this.visibleTabs.add(e):(this.visibleTabs.delete(e),this.audibleTabs.has(e)||this.endBackgroundTracking(e))}async handleTabRemoved(e){var s;const t=this.pendingStarts.get(e);t&&(clearTimeout(t.timeoutId),this.pendingStarts.delete(e)),this.visibleTabs.delete(e),this.audibleTabs.delete(e),((s=this.activeTab)==null?void 0:s.tabId)===e&&await this.endActiveTracking(),await this.endBackgroundTracking(e)}async handleIdleStateChanged(e){const t=this.isIdle;if(this.isIdle=e!=="active",this.isIdle&&!t){r("User became idle"),await this.endActiveTracking();for(const s of this.backgroundTabs.keys())await this.endBackgroundTracking(s)}else!this.isIdle&&t&&(r("User became active"),await this.initializeCurrentState())}async startActiveTracking(e,t,s){const n=this.pendingStarts.get(e);n&&(clearTimeout(n.timeoutId),this.pendingStarts.delete(e)),await this.endActiveTracking();const g=setTimeout(()=>{this.pendingStarts.delete(e),this.confirmActiveStart(e,t,s)},O);this.pendingStarts.set(e,{tabId:e,domain:s,url:t,isBackground:!1,scheduledTime:Date.now(),timeoutId:g}),r("Scheduled active tracking start for",s,"in",O,"ms")}confirmActiveStart(e,t,s){const n=Date.now();this.activeTab={tabId:e,domain:s,url:t,isBackground:!1,startTime:n,isTracking:!0};const g={type:"start",domain:s,isBackground:!1,at:R()};L(s,this.settings)&&(g.url=t),this.pendingEvents.push(g),r("Started active tracking:",s)}async endActiveTracking(){var n;if(this.activeTab){const g=this.pendingStarts.get(this.activeTab.tabId);g&&!g.isBackground&&(clearTimeout(g.timeoutId),this.pendingStarts.delete(this.activeTab.tabId))}if(!((n=this.activeTab)!=null&&n.isTracking)){this.activeTab=null;return}const e=this.activeTab,t=Date.now()-e.startTime,s={type:"end",domain:e.domain,isBackground:!1,at:R()};L(e.domain,this.settings)&&(s.url=e.url),this.pendingEvents.push(s),await te(e.domain,t,!1),r("Ended active tracking:",e.domain,"duration:",t),this.activeTab=null}async maybeStartBackgroundTracking(e,t){var P;if(this.isPaused||this.isIdle||this.backgroundTabs.has(e)||((P=this.activeTab)==null?void 0:P.tabId)===e||!j(t))return;const s=$(t);if(F(s,this.settings.blocklist))return;const n=this.visibleTabs.has(e),g=this.audibleTabs.has(e);if(!n&&!g)return;const u=this.pendingStarts.get(e);u&&(clearTimeout(u.timeoutId),this.pendingStarts.delete(e));const S=setTimeout(()=>{this.pendingStarts.delete(e),this.confirmBackgroundStart(e,t,s)},O);this.pendingStarts.set(e,{tabId:e,domain:s,url:t,isBackground:!0,scheduledTime:Date.now(),timeoutId:S}),r("Scheduled background tracking start for",s,"in",O,"ms")}confirmBackgroundStart(e,t,s){const n=Date.now(),g={tabId:e,domain:s,url:t,isBackground:!0,startTime:n,isTracking:!0};this.backgroundTabs.set(e,g);const u={type:"start",domain:s,isBackground:!0,at:R()};L(s,this.settings)&&(u.url=t),this.pendingEvents.push(u),r("Started background tracking:",s)}async endBackgroundTracking(e){const t=this.pendingStarts.get(e);t&&t.isBackground&&(clearTimeout(t.timeoutId),this.pendingStarts.delete(e));const s=this.backgroundTabs.get(e);if(!(s!=null&&s.isTracking)){this.backgroundTabs.delete(e);return}const n=Date.now()-s.startTime,g={type:"end",domain:s.domain,isBackground:!0,at:R()};L(s.domain,this.settings)&&(g.url=s.url),this.pendingEvents.push(g),await te(s.domain,n,!0),r("Ended background tracking:",s.domain,"duration:",n),this.backgroundTabs.delete(e)}async setPaused(e){if(this.isPaused!==e){if(this.isPaused=e,this.isPaused){await this.endActiveTracking();for(const t of this.backgroundTabs.keys())await this.endBackgroundTracking(t);for(const t of this.pendingStarts.values())clearTimeout(t.timeoutId);this.pendingStarts.clear()}else await this.initializeCurrentState();await Te({isPaused:this.isPaused,sessionStartTime:this.sessionStartTime}),r("Tracking",this.isPaused?"paused":"resumed")}}async togglePause(){return await this.setPaused(!this.isPaused),this.isPaused}getPendingEvents(){const e=[...this.pendingEvents];return this.pendingEvents=[],e}getIsIdle(){return this.isIdle}async getStatsResponse(){var n;const e=await X();let t="tracking";this.isPaused?t="paused":this.isIdle&&(t="idle");let s=0;return(n=this.activeTab)!=null&&n.isTracking&&(s=Date.now()-this.activeTab.startTime),{todayStats:e,currentSession:{activeTab:this.activeTab,sessionStartTime:this.sessionStartTime,currentSiteTime:s},status:t}}updateSettings(e){this.settings=e}}const y=new be,N="auth";class ke{constructor(){f(this,"tokens",null);f(this,"userEmail",null);f(this,"refreshTimeoutId",null);f(this,"onAuthChangeCallbacks",[])}async initialize(){r("Initializing AuthManager"),await this.loadStoredAuth(),this.tokens&&this.scheduleTokenRefresh()}async loadStoredAuth(){try{const t=(await l.storage.local.get(N))[N];t!=null&&t.tokens&&(t.tokens.expiresAt>Date.now()?(this.tokens=t.tokens,this.userEmail=t.userEmail,r("Loaded stored auth for:",this.userEmail)):(r("Stored token expired, attempting refresh"),await this.refreshToken(t.tokens.refreshToken)?this.userEmail=t.userEmail:await this.clearStoredAuth()))}catch(e){w("Error loading stored auth:",e)}}async saveAuth(){try{this.tokens&&this.userEmail&&await l.storage.local.set({[N]:{tokens:this.tokens,userEmail:this.userEmail}})}catch(e){w("Error saving auth:",e)}}async clearStoredAuth(){try{await l.storage.local.remove(N)}catch(e){w("Error clearing stored auth:",e)}}async login(e){r("Attempting login for:",e.email);try{const t=await fetch(`${D}${ce}`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!t.ok){const g=(await t.json().catch(()=>({}))).message||`Login failed: ${t.status}`;return w("Login failed:",g),{success:!1,error:g}}const s=await t.json();return this.tokens={accessToken:s.accessToken,refreshToken:s.refreshToken,expiresAt:Date.now()+s.expiresIn*1e3},this.userEmail=e.email,await this.saveAuth(),this.scheduleTokenRefresh(),this.notifyAuthChange(),r("Login successful for:",e.email),{success:!0}}catch(t){return w("Login error:",t),{success:!1,error:"Network error. Please check your connection."}}}async logout(){if(r("Logging out"),this.refreshTimeoutId&&(clearTimeout(this.refreshTimeoutId),this.refreshTimeoutId=null),this.tokens)try{await fetch(`${D}${ue}`,{method:"POST",headers:{Authorization:`Bearer ${this.tokens.accessToken}`,"Content-Type":"application/json"},body:JSON.stringify({refreshToken:this.tokens.refreshToken})})}catch{}this.tokens=null,this.userEmail=null,await this.clearStoredAuth(),this.notifyAuthChange(),r("Logout complete")}async refreshToken(e){var s;const t=e||((s=this.tokens)==null?void 0:s.refreshToken);if(!t)return r("No refresh token available"),!1;r("Refreshing access token");try{const n=await fetch(`${D}${le}`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({refreshToken:t})});if(!n.ok)return w("Token refresh failed:",n.status),e||await this.logout(),!1;const g=await n.json();return this.tokens={accessToken:g.accessToken,refreshToken:t,expiresAt:Date.now()+g.expiresIn*1e3},await this.saveAuth(),this.scheduleTokenRefresh(),r("Token refreshed successfully"),!0}catch(n){return w("Token refresh error:",n),e||await this.logout(),!1}}scheduleTokenRefresh(){if(this.refreshTimeoutId&&clearTimeout(this.refreshTimeoutId),!this.tokens)return;const e=this.tokens.expiresAt-Date.now(),t=Math.max(0,e-he);r("Scheduling token refresh in",Math.round(t/1e3),"seconds"),this.refreshTimeoutId=setTimeout(()=>{this.refreshToken()},t)}getAccessToken(){return this.tokens?this.tokens.expiresAt<=Date.now()?(r("Access token expired"),null):this.tokens.accessToken:null}isAuthenticated(){return this.tokens!==null&&this.tokens.expiresAt>Date.now()}getAuthState(){return{isAuthenticated:this.isAuthenticated(),userEmail:this.userEmail||void 0,tokens:this.tokens||void 0}}onAuthChange(e){this.onAuthChangeCallbacks.push(e)}notifyAuthChange(){const e=this.getAuthState();for(const t of this.onAuthChangeCallbacks)try{t(e)}catch(s){w("Error in auth change callback:",s)}l.runtime.sendMessage({type:"AUTH_STATE_CHANGED",payload:e}).catch(()=>{})}async forceRefresh(){return this.refreshToken()}}const x=new ke;async function we(i,e){const t=x.getAccessToken();if(!t)return r("Not authenticated, queuing events"),i.length>0&&await q(i),!1;const s=await se(),n=[...s,...i];if(n.length===0&&!e)return r("No events to send, skipping heartbeat"),!0;const g={heartbeatAt:R(),isIdle:e,events:n};try{r("Sending heartbeat:",g);const u=await fetch(`${D}${J}`,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${t}`},body:JSON.stringify(g)});if(u.status===401){if(r("Received 401, attempting token refresh"),await x.forceRefresh()){const P=x.getAccessToken();if(P&&(await fetch(`${D}${J}`,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${P}`},body:JSON.stringify(g)})).ok)return s.length>0&&await ie(),r("Heartbeat sent successfully after token refresh"),!0}return i.length>0&&await q(i),!1}if(!u.ok)throw new Error(`API returned ${u.status}: ${u.statusText}`);return s.length>0&&(await ie(),r("Cleared queued events after successful send")),r("Heartbeat sent successfully"),!0}catch(u){return w("Failed to send heartbeat:",u),i.length>0&&await q(i),!1}}const re="heartbeat";async function z(){r("Background service worker starting");try{await x.initialize(),await y.initialize(),await l.alarms.create(re,{periodInMinutes:de/6e4}),x.onAuthChange(i=>{r("Auth state changed:",i.isAuthenticated),i.isAuthenticated||y.setPaused(!0)}),r("Background service worker initialized")}catch(i){w("Failed to initialize:",i)}}l.alarms.onAlarm.addListener(async i=>{if(i.name===re)if(r("Heartbeat alarm triggered"),x.isAuthenticated()){const e=y.getPendingEvents(),t=y.getIsIdle();await we(e,t)}else r("Skipping heartbeat - not authenticated")}),l.runtime.onMessage.addListener(async(i,e)=>{switch(r("Received message:",i.type),i.type){case"GET_STATS":{const t=await y.getStatsResponse();return x.isAuthenticated()||(t.status="unauthenticated"),t}case"GET_CURRENT_STATE":{const t=await y.getStatsResponse();return x.isAuthenticated()||(t.status="unauthenticated"),t}case"TOGGLE_PAUSE":return{isPaused:await y.togglePause()};case"UPDATE_SETTINGS":{const t=i.payload;return await Q(t),y.updateSettings(t),{success:!0}}case"LOGIN":{const t=i.payload,s=await x.login(t);return s.success&&y.setPaused(!1),s}case"LOGOUT":return await x.logout(),y.setPaused(!0),{success:!0};case"GET_AUTH_STATE":return x.getAuthState();case"GET_VISIBILITY":return null;default:return r("Unknown message type:",i.type),null}}),l.runtime.onInstalled.addListener(async i=>{r("Extension installed/updated:",i.reason),i.reason==="install"&&(await Q({blocklist:[],trackFullUrlDomains:[]}),r("Default settings saved")),await z()}),l.runtime.onStartup.addListener(async()=>{r("Browser started"),await z()}),z().catch(w)})();
